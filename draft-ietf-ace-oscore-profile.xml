<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY SELF "[[this specification]]">
<!ENTITY I-D.ietf-core-object-security SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-core-object-security.xml">
<!ENTITY I-D.selander-ace-cose-ecdhe SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.selander-ace-cose-ecdhe.xml">
<!ENTITY I-D.ietf-ace-oauth-authz SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-ace-oauth-authz.xml">
<!ENTITY I-D.ietf-ace-oauth-params SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-ace-oauth-params.xml">
<!ENTITY I-D.gerdes-ace-dcaf-authorize SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.gerdes-ace-dcaf-authorize.xml">
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC7252 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7252.xml">
<!ENTITY RFC8152 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8152.xml">
<!ENTITY RFC4949 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4949.xml">
<!ENTITY RFC6749 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6749.xml">
<!ENTITY RFC7049 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7049.xml">
<!ENTITY RFC7231 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7231.xml">
<!ENTITY RFC8392 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8392.xml">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-ace-oscore-profile-latest" category="std">

<front>

  <title abbrev="OSCORE Profile of ACE">OSCORE profile of the Authentication and Authorization for Constrained Environments Framework</title>


    <author initials="F." surname="Palombini" fullname="Francesca Palombini">
     <organization>Ericsson AB</organization>
      <address>
        <email>francesca.palombini@ericsson.com</email>
      </address>
    </author>
  <author fullname="Ludwig Seitz" initials="L." surname="Seitz">
      <organization>RISE SICS AB</organization>
      <address>
        <postal>
          <street>Scheelevagen 17</street>
          <!-- Reorder these if your country does things differently -->
          <city>Lund</city>
          <code>22370</code>
          <country>Sweden</country>
        </postal>
        <email>ludwig.seitz@ri.se</email>
        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>
      <author fullname="GÃ¶ran Selander" initials="G." surname="Selander">
      <organization>Ericsson AB</organization>
      <address>
        <email>goran.selander@ericsson.com</email>
        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>
  <author fullname="Martin Gunnarsson" initials="M." surname="Gunnarsson">
      <organization>RISE SICS AB</organization>
      <address>
        <postal>
          <street>Scheelevagen 17</street>
          <!-- Reorder these if your country does things differently -->
          <city>Lund</city>
          <code>22370</code>
          <country>Sweden</country>
        </postal>
        <email>martin.gunnarsson@ri.se</email>
        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>


    <date/>

    <area>Security</area>
    <workgroup>ACE Working Group</workgroup>
    <abstract>
      <t>
        This memo specifies a profile for the Authentication and Authorization for Constrained Environments (ACE) framework.  It utilizes Object Security for Constrained RESTful Environments (OSCORE) to provide communication security, server authentication, and proof-of-possession for a key owned by the client and bound to an OAuth 2.0 access token.
      </t>
      <!-- 
        Jim: Lookup on the RFC Editor page if you need to expand OAuth

        From editor's list of well known:
        OAuth     *- [seems to be more of a name rather than an abbreviation] 
      -->
    </abstract>

  </front>

  <middle>

    <section anchor="introduction" title=" Introduction"> 
      
      <t>
        This memo specifies a profile of the ACE framework <xref target="I-D.ietf-ace-oauth-authz"/>.  In this profile, a client and a resource server use CoAP <xref target="RFC7252"/> to communicate.  The client uses an access token, bound to a key (the proof-of-possession key) to authorize its access to the resource server.  In order to provide communication security, proof of possession, and server authentication they use Object Security for Constrained RESTful Environments (OSCORE) <xref target="I-D.ietf-core-object-security"/>.
      </t>

      <t>
        OSCORE specifies how to use CBOR Object Signing and Encryption (COSE) <xref target="RFC8152"/> to secure CoAP messages.
        Note that OSCORE can be used to secure CoAP messages, as well as HTTP and combinations of HTTP and CoAP; a profile of ACE similar to the one described in this document, with the difference of using HTTP instead of CoAP as communication protocol, could be specified analogously to this one.
      </t>

      <section anchor="terminology" title=" Terminology">

        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.  These words may also appear in this document in lowercase, absent their normative meanings.
        </t>

        <t>
          Certain security-related terms such as "authentication", "authorization", "confidentiality", "(data) integrity", "message  authentication code", and "verify" are taken from <xref target="RFC4949"/>.
        </t>

        <t>
          RESTful terminology follows HTTP <xref target="RFC7231"/>.
        </t>

        <t>
          Terminology for entities in the architecture is defined in OAuth 2.0 <xref target="RFC6749"/>, such as client (C), resource server (RS), and authorization server (AS). It is assumed in this document that a given resource on a specific RS is associated to a unique AS.
        </t>

        <t>
          Note that the term "endpoint" is used here, as in <xref target="I-D.ietf-ace-oauth-authz"/>, following its OAuth definition, which is to denote resources such as token and introspect at the AS and authz-info at the RS.  The CoAP <xref target="RFC7252"/> definition, which is "An entity participating in the CoAP protocol" is not used in this memo.
        </t> 
        <!-- UNDONE: changed the above to "resource" in the whole doc-->

      </section> <!-- ends from line 117-->
    </section> <!-- ends from line 106-->

    <section title="Protocol Overview"> 
    
      <t>
        This section gives an overview on how to use the ACE Framework <xref target="I-D.ietf-ace-oauth-authz"/> to secure the communication between a client and a resource server using OSCORE <xref target="I-D.ietf-core-object-security"/>. The parameters needed by the client to negotiate the use of this profile with the authorization server, as well as OSCORE setup process, are described in detail in the following sections.
      </t>

      <t>
        This profile requires a client to retrieve an access token from the AS for the resource it wants to access on a RS, using the token endpoint, as specified in section 5.6 of <xref target="I-D.ietf-ace-oauth-authz"/>.  To determine the AS in charge of a resource hosted at the RS, the client C MAY send an initial Unauthorized Resource Request message to the RS. The RS then denies the request and sends the address of its AS back to the client C as specified in section 5.1 of <xref target="I-D.ietf-ace-oauth-authz"/>. The access token request and response MUST be confidentiality-protected and ensure authenticity.  This profile RECOMMENDS the use of OSCORE between client and AS, but TLS or DTLS MAY be used additionally or instead.
      </t>

      <t>
        Once the client has retrieved the access token, it posts it to the RS using the authz-info endpoint and mechanisms specified in section 5.8 of <xref target="I-D.ietf-ace-oauth-authz"/>. If the access token is valid, the RS replies to this request with a 2.01 (Created) response, which contains a nonce N1.
      </t>

      <t>
        After receiving the nonce N1, the client generates a nonce N2, concatenates it with N1 and sets the ID Context in its Security Context (see section 3 of <xref target="I-D.ietf-core-object-security"/>) to N1 concatenated with N2. The client then derives the complete Security Context from the ID Context plus the parameters received from the AS.
      </t>

      <t>
        Finally, the client sends a request protected with OSCORE to the RS. This message contains the ID Context value. When receiving this request after the 2.01 (Created) response, the server extract the ID Context from it, verifies that the first part is equal to the nonce N1 it previously sent, and if so, sets its own ID Context and derives the complete Security Context from it plus the parameters received in the AS, following section 3.2 of <xref target="I-D.ietf-core-object-security"/>.  If the request verifies, then this Security Context is stored in the server, and used in the response, and in further communications with the client, until token expiration. Once the client receives a valid response, it does not continue to include the ID Context value in further requests.
      </t>

      <t>
        The use of random nonces during the exchange prevents the reuse of AEAD nonces and keys with different messages, in case of re-derivation of the Security Context both for Clients and Resource Servers from an old non-expired access token, e.g. in case of re-boot of either the client or RS. In fact, by using random nonces as ID Context, the request to the authz-info endpoint posting the same token results in a different Security Context, since Master Secret, Sender ID and Recipient ID are the same but ID Context is different. Therefore, the main requirement for the nonces is that they have a good amount of randomness. If random nonces were not used, a node re-using a non-expired old token would be susceptible to on-path attackers provoking the creation of OSCORE messages using old AEAD keys and nonces.
      </t>

      <t>
        An overview of the profile flow for the OSCORE profile is given in <xref target="prof-overview"/>.
      </t>


      <figure anchor="prof-overview" title="Protocol Overview">
        <artwork><![CDATA[
   C                            RS                   AS
   | [-- Resource Request --->] |                     |
   |                            |                     |
   | [<----- AS Information --] |                     |
   |                            |                     |
   | ----- POST /token  ----------------------------> |
   |                            |                     |
   | <---------------------------- Access Token ----- |
   |                               + RS Information   |
   | ---- POST /authz-info ---> |                     |
   |                            |                     |
   | <--- 2.01 Created (N1) --- |                     |
   |                            |                     |
 /Sec Context Derivation/       |                     |
   |                            |                     |
   | ---- OSCORE Request -----> |                     |
   |         (N1, N2)           |                     |
   |                            |                     |
   |               /Sec Context Derivation/           |
   |                            |                     |
   | <--- OSCORE Response ----- |                     |
   |                            |                     |
   | ---- OSCORE Request -----> |                     |
   |                            |                     |
   | <--- OSCORE Response ----- |                     |
   |           ...              |                     |
]]>
        </artwork>
      </figure>

    </section> <!-- closes from line 142 -->
    

    <section anchor="client-as" title="Client-AS Communication"> 

      <t>
        The following subsections describe the details of the POST request and response to the token endpoint between client and AS. Section 3.2 of <xref target="I-D.ietf-core-object-security"/> defines how to derive a Security Context based on a shared master secret and a set of other parameters, established between client and server, which the client receives from the AS in this exchange.  The proof-of-possession key (pop-key) provisioned from the AS MUST be used as master secret in OSCORE.
      </t>

      <section anchor="c-as" title="C-to-AS: POST to token endpoint"> 

        <t>
          The client-to-AS request is specified in Section 5.6.1 of <xref target="I-D.ietf-ace-oauth-authz"/>.
        </t>

        <t>
          The client MUST send this POST request to the token endpoint over a secure channel that guarantees authentication, message integrity and confidentiality (see <xref target="introsp"/>). 
        </t>

        <t>
          An example of such a request, in CBOR diagnostic notation without the tag and value abbreviations is reported in <xref target="ex0"/>
        </t>

        <figure anchor="ex0" title="Example C-to-AS POST /token request for an access token bound to a symmetric key.">
          <artwork><![CDATA[
    Header: POST (Code=0.02)
    Uri-Host: "as.example.com"
    Uri-Path: "token"
    Content-Format: "application/ace+cbor"
    Payload:
    {
      "grant_type" : "client_credentials",
      "client_id" : "myclient",
      "req_aud" : "tempSensor4711",
      "scope" : "read"
     }
]]>
          </artwork>
        </figure>
      
        <t>
          If the client wants to update its access rights without changing an existing OSCORE Security Context, it MUST include in its POST request to the token endpoint a req_cnf object carrying the client's identifier (that was assigned in section <xref target="as-c"/>) in the kid field. This identifier can be used by the AS to determine the shared secret to construct the proof-of-possession token and therefore MUST identify a symmetric key that was previously generated by the AS as a shared secret for the communication between the client and the RS. The AS MUST verify that the received value identifies a proof-of-possession key and token that have previously been issued to the requesting client. If that is not the case, the Client-to-AS request MUST be declined with the error code 'invalid_request' as defined in Section 5.6.3 of <xref target="I-D.ietf-ace-oauth-authz"/>.
        </t>

        <t>
          An example of such a request, in CBOR diagnostic notation without the tag and value abbreviations is reported in <xref target="ex7"/>
        </t>

        <figure anchor="ex7" title="Example C-to-AS POST /token request for updating rights to an access token bound to a symmetric key.">
          <artwork><![CDATA[
    Header: POST (Code=0.02)
    Uri-Host: "as.example.com"
    Uri-Path: "token"
    Content-Format: "application/ace+cbor"
    Payload:
    {
      "grant_type" : "client_credentials",
      "client_id" : "myclient",
      "req_aud" : "tempSensor4711",
      "scope" : "write",
      "req_cnf" : {
        "kid" : b64'Qg'
     }
]]>
          </artwork>
        </figure>
      

      </section> <!-- closes from line 227 -->

      <section anchor="as-c" title="AS-to-C: Access Token"> 

        <t>
          After verifying the POST request to the token endpoint and that the client is authorized to obtain an access token corresponding to its access token request, the AS responds as defined in section 5.6.2 of <xref target="I-D.ietf-ace-oauth-authz"/>. If the client request was invalid, or not authorized, the AS returns an error response as described in section 5.6.3 of <xref target="I-D.ietf-ace-oauth-authz"/>.
        </t>

        <t>
          The AS signals that the use of OSCORE is REQUIRED for a specific access token by including the "profile" parameter with the value "coap_oscore" in the access token response.  This means that the client MUST use OSCORE towards all resource servers for which this access token is valid, and follow <xref target="oscore-setup"/> to derive the security context to run OSCORE.
        </t>

        <t>
          Moreover, the AS MUST provision the following data:
        </t>

        <t>
          <list style="symbols">
            <t>a master secret</t>
            <t>a client identifier</t>
            <t>a server identifier</t>
          </list>
        </t>

        <t>
          Additionally, the AS MAY provision the following data, in the same response. 
        </t>

        <t>
          <list style="symbols">
            <t>an AEAD algorithm</t>
            <t>an HKDF algorithm</t>
            <t>a salt</t>
            <t>a replay window type and size</t>
          </list>
        </t>

        <t>
          The master secret MUST be communicated as the 'ms' field in the OSCORE_Security_Context in the 'cnf' parameter of the access token response as defined in Section 3.2 of <xref target="I-D.ietf-ace-oauth-params"/>.
          The OSCORE_Security_Context is a CBOR map object, defined in <xref target="oscore-sec-ctx"/>.
          The AEAD algorithm MAY be included as the 'alg' parameter in the OSCORE_Security_Context; the HKDF algorithm MAY be included
      	  as the 'hkdf' parameter of the OSCORE_Security_Context, the salt MAY be included as the 'salt' parameter of the
      	  COSCORE_Security_Context and the replay window type and size MAY be included as the 'rpl' of the OSCORE_Security_Context, as defined in <xref target="oscore-sec-ctx"/>.
        </t>
	      
        <t>
        	The same parameters MUST be included as metadata of the access token. This profile RECOMMENDS the use of CBOR web token (CWT) as specified in  <xref target="RFC8392"/>. If the token is a CWT, the same OSCORE_Security_Context structure defined above MUST be placed in the 'cnf' claim of this token. 
	      </t>

        <t>
          The AS MUST also assign identifiers to both client and RS, which are then used as Sender ID and Recipient ID in the OSCORE context as described in section 3.1 of <xref target="I-D.ietf-core-object-security"/>.  The client identifiers MUST be unique in the set of all clients on a single RS, and RS identifiers MUST be unique  in the set of all RS for any given client.  Moreover, these MUST be included in the OSCORE_Security_Context, as defined in <xref target="oscore-sec-ctx"/>.
        </t>

        <t>
          We assume in this document that a resource is associated to one single AS, which makes it possible to assume unique identifiers for each client requesting a particular resource to a RS.  If this is not the case, collisions of identifiers may appear in the RS, in which case the RS needs to have a mechanism in place to disambiguate identifiers or mitigate their effect.
          <!-- TODO: Add error response definition in the document for the RS to indicate "Id collision"-->
        </t>

        <t>
          Note that in <xref target="oscore-setup"/> C sets the Sender ID of its Security Context to the clientId value received and the Recipient ID to the serverId value, and RS does the opposite.
        </t>

        <t>
          <xref target="ex1"/> shows an example of such an AS response, in CBOR diagnostic notation without the tag and value abbreviations.
        </t>

        <figure anchor="ex1" title="Example AS-to-C Access Token response with OSCORE profile.">
          <artwork><![CDATA[
    Header: Created (Code=2.01)
    Content-Type: "application/cose+cbor"
    Payload:
    {
      "access_token" : b64'SlAV32hkKG ...
       (remainder of access token omitted for brevity)',
      "profile" : "coap_oscore",
      "expires_in" : "3600",
      "cnf" : {
        "OSCORE_Security_Context" : {
          "kty" : "Symmetric",
          "alg" : "AES-CCM-16-64-128",
          "clientId" : b64'qA',
          "serverId" : b64'Qg',
          "k" : b64'+a+Dg2jjU+eIiOFCa9lObw'
        }
      }
    }
]]>
          </artwork>
        </figure>

        <t>
          <xref target="ex2"/> shows an example CWT, containing the necessary OSCORE parameters in the 'cnf' claim, in CBOR diagnostic notation without tag and value abbreviations.
        </t>

        <figure anchor="ex2" title="Example CWT with OSCORE parameters.">
          <artwork><![CDATA[
  {
    "aud" : "tempSensorInLivingRoom",
    "iat" : "1360189224",
    "exp" : "1360289224",
    "scope" :  "temperature_g firmware_p",
    "cnf" : {
      "OSCORE_Security_Context" : {
        "kty" : "Symmetric",
        "alg" : "AES-CCM-16-64-128",
        "clientId" : b64'Qg',
        "serverId" : b64'qA',
        "k" : b64'+a+Dg2jjU+eIiOFCa9lObw' 
    }
  }
]]>
          </artwork>
        </figure>

        <t>
          If the client has requested an update to its access rights using the same OSCORE Security Context, which is valid and authorized, the AS MUST omit the 'cnf' parameter in the response, and MUST carry the client identifier in the 'kid' field in the 'cnf' parameter of the token. The client identifier needs to be provisioned, in order for the RS to identify the previously generated Security Context.
        </t>

        <t>
          <xref target="ex5"/> shows an example of such an AS response, in CBOR diagnostic notation without the tag and value abbreviations.
        </t>

        <figure anchor="ex5" title="Example AS-to-C Access Token response with OSCORE profile, for update of access rights.">
          <artwork><![CDATA[
    Header: Created (Code=2.01)
    Content-Type: "application/cose+cbor"
    Payload:
    {
      "access_token" : b64'SlAV32hkKG ...
       (remainder of access token omitted for brevity)',
      "profile" : "coap_oscore",
      "expires_in" : "3600"
    }
]]>
          </artwork>
        </figure>

        <t>
          <xref target="ex6"/> shows an example CWT, containing the necessary OSCORE parameters in the 'cnf' claim for update of access rights, in CBOR diagnostic notation without tag and value abbreviations.
        </t>

        <figure anchor="ex6" title="Example CWT with OSCORE parameters for update of access rights.">
          <artwork><![CDATA[
  {
    "aud" : "tempSensorInLivingRoom",
    "iat" : "1360189224",
    "exp" : "1360289224",
    "scope" :  "temperature_h",
    "cnf" : {
      "kid" : b64'Qg'
    }
  }
]]>
          </artwork>
        </figure>

        <section anchor="oscore-sec-ctx" title="OSCORE_Security_Context Object">

          <t>
            A OSCORE_Security_Context is a CBOR map object.  The set of common parameters that can appear in a OSCORE_Security_Context object can be found in the IANA "OSCORE Security Context Parameters" registry (Section <xref target="sec-ctx-params-reg"/>).
          </t>

          <t>
            The CDDL grammar describing OSCORE_Security_Context is:
          </t>

          <figure><artwork type="CDDL"><![CDATA[
OSCORE_Security_Context = {
    ? 1 => bstr,              ; ms
    ? 2 => bstr,              ; clientId
    ? 3 => bstr,              ; serverId
    ? 4 => tstr / int,        ; hkdf
    ? 5 => tstr / int,        ; alg
    ? 6 => bstr,              ; salt
    ? 7 => bstr / tstr        ; rpl
}
]]></artwork></figure>

          <t>
            This document defines a set of parameters for an OSCORE_Security_Context object.
            <xref target="table-key-labels"/> provides a summary of the parameters defined in this section.
          </t>

          <texttable title="OSCORE_Security_Context Map Labels" anchor="table-key-labels">
            <ttcol align='left'>name</ttcol>
            <ttcol align='left'>label</ttcol>
            <ttcol align='left' width="14em">CBOR type</ttcol>
            <ttcol align='left'>registry</ttcol>
            <ttcol align='left'>description</ttcol>
            
            <c>ms</c>        <c>1</c>        <c>bstr</c>  <c></c>        <c>OSCORE Master Secret value</c>
            <c>clientId</c>        <c>2</c>        <c>bstr</c>        <c></c>        <c>OSCORE Sender ID value of the client, OSCORE Recipient ID value of the server</c>
            <c>serverId</c>        <c>3</c>        <c>bstr</c>        <c></c>        <c>OSCORE Sender ID value of the server, OSCORE Recipient ID value of the client</c>
            <c>hkdf</c>        <c>4</c>        <c>bstr / int</c>        <c>COSE Algorithm Values (HMAC-based)</c>        <c>OSCORE HKDF value</c>
            <c>alg</c>        <c>5</c>        <c>tstr / int</c>  <c>COSE Algorithm Values (AEAD)</c>        <c>OSCORE AEAD Algorithm value</c>
            <c>salt</c>        <c>6</c>        <c>bstr</c>        <c></c>        <c>OSCORE Master Salt value</c>
            <c>rpl</c>    <c>7</c>        <c>bstr / int</c> <c></c>     <c>OSCORE Replay Window Type and Size</c>
          </texttable>

          <t>
            <list style="hanging">
              <t hangText="ms:">
                This parameter is used to carry the OSCORE Master Secret value, which is a byte string. For more information about this field, see section 3.1 of <xref target="I-D.ietf-core-object-security"/>.
              </t>

              <t hangText="clientId:">
                This parameter is used to carry a client identifier as a byte string. This identifier is used as OSCORE Sender ID in the client and OSCORE Recipient ID in the server. For more information about this field, see section 3.1 of <xref target="I-D.ietf-core-object-security"/>.
              </t>

              <t hangText="serverId:">
                This parameter is used to carry a server identifier as a byte string. This identifier is used as OSCORE Sender ID in the client and OSCORE Recipient ID in the server. For more information about this field, see section 3.1 of <xref target="I-D.ietf-core-object-security"/>.
              </t>
              
              <t hangText="hkdf:">
                This parameter is used to carry the OSCORE HKDF Algorithm, which can be an integer or a text string.
                The int value MUST be taken and can only encode an alg from the set of HMAC-based KDF algorithms in the COSE Algorithms registry.
                For more information about this field, see section 3.1 of <xref target="I-D.ietf-core-object-security"/>
              </t>

              <t hangText="alg:">
                This parameter is used to carry the OSCORE AEAD Algorithm, which can be an integer or a text string.
                The int value MUST be taken and can only encode an alg from the set of AEAD algorithms in the COSE Algorithms registry. 
                For more information about this field, see section 3.1 of <xref target="I-D.ietf-core-object-security"/>
              </t>

              <t hangText="salt:">
                This parameter is used to carry the OSCORE Master Salt value, which is a byte string. For more information about this field, see section 3.1 of <xref target="I-D.ietf-core-object-security"/>.
              </t>

              <t hangText="repl:">
                This parameter is used to carry the OSCORE Replay Window Size and Type value, encoded as a bstr.
                For more information about this field, see section 3.1 of <xref target="I-D.ietf-core-object-security"/>.
              </t>
              
            </list>
          </t>

        </section>

      </section> <!-- ends for line 266-->
    
    </section> <!-- ends for line 221 -->

    <section anchor="c-rs1" title="Client-RS Communication">

      <t>
        The following subsections describe the details of the POST request and response to the authz-info endpoint between client and RS. The client posts the token that includes the materials provisioned by the AS to the RS, which can then use Section 3.2 of <xref target="I-D.ietf-core-object-security"/> to derive a security context based on a shared master secret and a set of other parameters, established between client and server.
      </t>

      <t>
        Note that the proof-of-possession required to bind the access token to the
        client is implicitly performed by generating the shared OSCORE Security Context using
        the pop-key as master secret, for both client and RS.  An attacker
        using a stolen token will not be able to generate a valid OSCORE context and
        thus not be able to prove possession of the pop-key.
      </t>


      <section anchor="c-rs" title="C-to-RS: POST to authz-info endpoint">

        <t>
          The client MUST use CoAP and the Authorization Information resource as described in section 5.8.1 of <xref target="I-D.ietf-ace-oauth-authz"/> to transport the token to the RS.
        </t>

        <t>
          The authz-info endpoint is not protected, nor are the responses from this resource.
        </t>

        <t>
          The access token MUST be encrypted, since it is
          transferred from the client to the RS over an unprotected channel.
        </t>

        <t>
        	Note that a client may be required to re-POST the access token, since an RS may delete a stored access token, due to lack of memory.
        </t>

        <t>
          <xref target="ex3"/> shows an example of the request sent from the client to the RS.
        </t>

        <figure anchor="ex3" title="Example C-to-RS POST /authz-info request using CWT">
          <artwork><![CDATA[
      Header: POST (Code=0.02)
      Uri-Host: "rs.example.com"
      Uri-Path: "authz-info"
      Content-Format: "application/cwt"
      Payload:
       b64'SlAV32hkKG ...
         (remainder of access token omitted for brevity)',
  ]]>
          </artwork>
        </figure>

      </section> <!-- ends for line 418 -->

      <section anchor="rs-c" title="RS-to-C: 2.01 (Created)">

        <t>
          The RS MUST follow the procedures defined in section 5.8.1 of <xref target="I-D.ietf-ace-oauth-authz"/>: the RS MUST verify the validity of the token. If the token is valid, the RS MUST respond to the POST request with 2.01 (Created). If the token is valid but is associated to claims that the RS cannot process (e.g., an unknown scope) the RS MUST respond with a response code equivalent to the CoAP code 4.00 (Bad Request). In the latter case the RS MAY provide additional information in the error response, in order to clarify what went wrong. The RS MAY make an introspection request to validate the token before responding to the POST request to the authz-info endpoint. 
        </t>

        <t>
          Additionally, the RS MUST generate a nonce (N1) with a good amount of randomness, and include it in the payload of the 2.01 (Created) response as a CBOR byte string. This profile RECOMMENDS to use a nonce of 64 bits. The RS MUST store this nonce as long as the access token related to it is still valid. 
        </t>

        <t>
        	Note that, when using this profile, an identifier of the token (e.g., the cti for a CWT) is not transported in the payload of this request, as section 5.8.1 of <xref target="I-D.ietf-ace-oauth-authz"/> allows. 
        </t>

        <t>
          <xref target="ex4"/> shows an example of the response sent from the RS to the client.
        </t>

        <figure anchor="ex4" title="Example RS-to-C 2.01 (Created) response">
          <artwork><![CDATA[
      Header: Created (Code=2.01)
      Content-Format: "application/cbor"
      Payload:
       h'018a278f7faab55a',
  ]]>
          </artwork>
        </figure>

        <t>
          When receiving an updated access token with updated authorization information from the client (see section <xref target="c-as"/>), it is RECOMMENDED that the RS overwrites the previous token, that is only the latest authorization information in the token received by the RS is valid. This simplifies for the RS to keep track of authorization information for a given client. 
        </t>
        
        <t>
          As specified in section 5.8.3 of <xref target="I-D.ietf-ace-oauth-authz"/>, the RS MUST notify the client with an error response with code 4.01 (Unauthorized) for any long running request before terminating the session, when the access token expires.
        </t>

      </section> <!-- ends for line 452-->

      <section anchor="oscore-setup" title="OSCORE Setup">

        <t>
          Once receiving the 2.01 (Created) response from the RS, following the POST request to authz-info endpoint, the client MUST extract the nonce N1 from the CBOR byte string in the payload of the response. The client MUST generate itself a nonce (N2) with a good amount of randomness. This profile RECOMMENDS to use a nonce of 64 bits. Then, the client MUST set the ID Context of the Security Context created to communicate with the RS to the concatenation of N1 and N2, in this order: ID Context = N1 | N2, where | denotes byte string concatenation. The client MUST set the Master Secret, Sender ID and Recipient ID from the parameters received from the AS in <xref target="as-c"/>. The client MUST set the AEAD Algorithm, Master Salt, HKDF and Replay Window from the parameters received from the AS in <xref target="as-c"/>, if present. In case these parameters are omitted, the default values are used as described in section 3.2 of <xref target="I-D.ietf-core-object-security"/>. After that, the client MUST derive the complete Security Context following section 3.2.1 of <xref target="I-D.ietf-core-object-security"/>. From this point on, the client MUST use this Security Context to communicate with the RS when accessing the resources as specified by the authorization information.
        </t>

        <t>
          The client then uses this Security Context to send requests to RS using OSCORE. In the first request sent to the RS, the client MUST include the kid context, with value ID Context, i.e. N1 concatenated with N2. The client needs to make sure the RS receives the kid context, possibly adding the kid context to later requests, until it receives a valid OSCORE response from the RS using the same Security Context.
        </t>

        <t>
          When the RS receives this first OSCORE-protected request, it MUST extract the kid context from the message first. Then, it needs to verify that the first part of the kid context corresponds to the nonce N1 it previously sent, and that it is followed by a non-zero-length byte string. If that is verified, the RS MUST set the ID Context to the kid context value. Then, the RS MUST set the Master Secret, Sender ID and Recipient ID from the parameters received from the client in the access token in <xref target="c-rs"/>. The RS MUST set the AEAD Algorithm, Master Salt, HKDF and Replay Window from the parameters received from the client in the access token in <xref target="c-rs"/>, if present. In case these parameters are omitted, the default values are used as described in section 3.2 of <xref target="I-D.ietf-core-object-security"/>. After that, the RS MUST derive the complete Security Context following section 3.2.1 of <xref target="I-D.ietf-core-object-security"/>, and MUST associate this Security Context with the authorization information from the access token. Then, the RS MUST delete the nonce N1 from memory.
        </t>

        <t>
          The RS then uses this Security Context to verify the request and send responses to RS using OSCORE. If OSCORE verification fails, error responses are used, as specified in section 8 of <xref target="I-D.ietf-core-object-security"/>. Additionally, if OSCORE verification succeeds, the verification of access rights is performed as described in section <xref target="tok-ver"/>. The RS MUST NOT use the Security Context after the related token has expired, and MUST respond with a unprotected 4.01 (Unauthorized) error message.
        </t>

      </section> <!-- ends from line 481-->

      <section anchor="tok-ver" title="Access rights verification">

        <t>
          The RS MUST follow the procedures defined in section 5.8.2 of <xref target="I-D.ietf-ace-oauth-authz"/>: if an RS receives an OSCORE-protected request from a client, then it processes according to <xref target="I-D.ietf-core-object-security"/>. If OSCORE verification succeeds, and the target resource
          requires authorization, the RS retrieves the authorization information from the access token associated to the Security Context. The RS then MUST verify that the authorization information covers the resource and the action requested.
        </t>

        <t>
         The response code MUST be 4.01 (Unauthorized) in case the client has
         not used the Security Context associated with the access token, or if RS has no valid access token for the client.  If RS has an access token for the client but
         not for the resource that was requested, RS MUST reject the request
         with a 4.03 (Forbidden).  If RS has an access token for the client
         but it does not cover the action that was requested on the resource,
         RS MUST reject the request with a 4.05 (Method Not Allowed).
        </t>

      </section>

    </section>

    <section anchor="introsp" title="Secure Communication with AS">

      <t>
        As specified in the ACE framework (section 5.7 of <xref target="I-D.ietf-ace-oauth-authz"/>), the requesting entity (RS and/or client) and the AS communicates via the introspection or token endpoint. The use of CoAP and OSCORE for this communication is RECOMMENDED in this profile, other protocols (such as HTTP and DTLS or TLS) MAY be used instead.
      </t>

      <t>
        If OSCORE is used, the requesting entity and the AS are expected to have pre-established security contexts in place.  How these security contexts are established is out of scope for this profile.  Furthermore the requesting entity and the AS communicate using OSCORE (<xref target="I-D.ietf-core-object-security"/>) through the introspection endpoint as specified in section 5.7 of <xref target="I-D.ietf-ace-oauth-authz"/> and through the token endpoint as specified in section 5.6 of <xref target="I-D.ietf-ace-oauth-authz"/>.
      </t>

    </section>

     <section anchor="sec-ctx-discard" title="Discarding the Security Context">

      <t>
        There are a number of scenarios where a client or RS needs to discard the OSCORE security context, and acquire a new one.
      </t>

      <t>
        The client MUST discard the current security context associated with an RS when:

      <list style="symbols">
        <t> the Sequence Number space ends. </t>
        <t> the access token associated with the context expires. </t>
        <t> the client receives a number of 4.01 Unauthorized responses to OSCORE requests using the same security context. The exact number needs to be specified by the application. </t>
        <t> the client receives a new nonce in the 2.01 Created response (see <xref target="rs-c"/>) to a POST request to the authz-info endpoint, when re-posting a non-expired token associated to the existing context. </t>
      </list>
      </t>

      <t>
        The RS MUST discard the current security context associated with a client when:

      <list style="symbols">
        <t> Sequence Number space ends. </t>
        <t> Access token associated with the context expires. </t>
      </list>
      </t>

    </section>

    <section title="Security Considerations">

      <t>
        This document specifies a profile for the Authentication and
        Authorization for Constrained Environments (ACE) framework
        <xref target="I-D.ietf-ace-oauth-authz"/>.  Thus the general security
        considerations from the framework also apply to this profile.
      </t>

      <t>
        Furthermore the general security considerations of OSCORE <xref
        target="I-D.ietf-core-object-security"/> also apply to this specific
        use of the OSCORE protocol.
      </t>
      
      <t>
        OSCORE is designed to secure point-to-point communication,
        providing a secure binding between the request and the response(s).
        Thus the basic OSCORE protocol is not intended for use in
        point-to-multipoint communication (e.g. multicast, publish-subscribe).
        Implementers of this profile should make sure that their usecase
        corresponds to the expected use of OSCORE, to prevent weakening the
        security assurances provided by OSCORE.
      </t>
      
      <t>
        Since the use of nonces in the exchange guarantees uniqueness of AEAD keys and nonces even in case of re-boots, a good amount of randomness is required. If that is not guaranteed, nodes are still susceptible to re-using nonces and keys, in case the Security Context is lost, and on-path attacker replaying messages.
      </t>

      <t>
        This profiles recommends that the RS maintains a single access token for a client. The use of multiple access tokens for a single client increases the strain on the resource server as it must consider every access token and calculate the actual permissions of the client. Also, tokens may contradict each other which may lead the server to enforce wrong permissions. If one of the access tokens expires earlier than others, the resulting permissions may offer insufficient protection. Developers should avoid using multiple access tokens for a client. 
      </t>
    
    </section> <!-- ends from line 518-->

    <section title="Privacy Considerations">
      <t>
        This document specifies a profile for the Authentication and
        Authorization for Constrained Environments (ACE) framework
        <xref target="I-D.ietf-ace-oauth-authz"/>.  Thus the general privacy
        considerations from the framework also apply to this profile.
      </t>
      <t>
        As this document uses OSCORE, thus the privacy considerations from
	<xref target="I-D.ietf-core-object-security"/> apply here as well.
      </t>

      <t>
      	An unprotected response to an unauthorized request may disclose information about the resource server and/or its existing relationship with the client. It is advisable to include as little information as possible in an unencrypted response. When an OSCORE Security Context already exists between the client and the resource server, more detailed information may be included.
      </t>      

      <t>
      	Note that some information might still leak after OSCORE is established, due to observable message sizes, the source, and the destination addresses.
      </t>
    </section> <!-- ends from line 539-->

    <section title=" IANA Considerations ">

       <t>Note to RFC Editor: Please replace all occurrences of "&SELF;"
      with the RFC number of this specification and delete this paragraph.</t>
   
      <section title="ACE OAuth Profile Registry">

        <t>The following registration is done for the ACE OAuth Profile
        Registry following the procedure specified in section 8.7 of <xref
        target="I-D.ietf-ace-oauth-authz"/>:</t>

        <t><?rfc subcompact="yes"?><list style='symbols'>
          <t>Profile name: coap_oscore</t>

      	  <t>Profile Description: Profile for using OSCORE to secure communication
      	between constrained nodes using the Authentication and Authorization
      	for Constrained Environments framework.</t>

      	  <t>Profile ID: TBD (value between 1 and 255)</t>
      	
      	  <t>Change Controller: IESG</t>

      	  <t>Specification Document(s): &SELF;</t>
        </list></t>

      </section>

      <section anchor="sec-ctx-params-reg" title="OSCORE Security Context Parameters Registry">
	
      <t>
          It is requested that IANA create a new registry entitled "OSCORE Security Context Parameters" registry.
          The registry is to be created as Expert Review Required.
          Guidelines for the experts is provided <xref target="review"/>.
          It should be noted that in additional to the expert review, some portions of the registry require a specification, potentially on standards track, be supplied as well.
        </t>

        <t>
          The columns of the registry are:
        </t>

        <t>
          <list style="hanging">
            <t hangText='name'>
              This is a descriptive name that enables easier reference to the item.  It is not used in the encoding.
            </t>
            <t hangText='label'>
              The value to be used to identify this algorithm.
              Key map labels MUST be unique.
              The label can be a positive integer, a negative integer or a string.
              Integer values between 0 and 255 and strings of length 1 are designated as Standards Track Document required.
              Integer values from 256 to 65535 and strings of length 2 are designated as Specification Required.
              Integer values of greater than 65535 and strings of length greater than 2 are designated as expert review.
              Integer values less than -65536 are marked as private use.
            </t>
            <t hangText='CBOR Type'>
              This field contains the CBOR type for the field.
            </t>
            <t hangText='registry'>
              This field denotes the registry that values may come from, if one exists.
            </t>
            <t hangText='description'>
              This field contains a brief description for the field.
            </t>
            <t hangText='specification'>
              This contains a pointer to the public specification for the field if one exists
            </t>
          </list>
        </t>

        <t>
          This registry will be initially populated by the values in <xref target="table-key-labels"/>.
          The specification column for all of these entries will be this document.
        </t>

      </section>

      <section title="CWT Confirmation Methods Registry">

        <t>The following registration is done for the CWT Confirmation Methods Registry following the procedure specified in section 7.2.1 of <xref target="I-D.ietf-ace-oauth-authz"/>:</t>

        <t><?rfc subcompact="yes"?><list style='symbols'>
          <t>Confirmation Method Name: "OSCORE_Security_Context"</t>

          <t>Confirmation Method Description: OSCORE_Security_Context carrying the OSCORE Security Context parameters</t>

          <t>Confirmation Key: TBD (value between 4 and 255)</t>

          <t>Confirmation Value Type(s): map</t>
        
          <t>Change Controller: IESG</t>

          <t>Specification Document(s): <xref target="oscore-sec-ctx"/> of &SELF;</t>
        </list></t>

      </section>


      <section title="Expert Review Instructions" anchor="review">
        <t>
          The IANA registry established in this document is defined as expert review.
          This section gives some general guidelines for what the experts should be looking for, but they are being designated as experts for a reason so they should be given substantial latitude.
        </t>

        <t>
          Expert reviewers should take into consideration the following points:

          <list style="symbols">
            <t>
              Point squatting should be discouraged.
              Reviewers are encouraged to get sufficient information for registration requests to ensure that the usage is not going to duplicate one that is already registered and that the point is likely to be used in deployments.
              The zones tagged as private use are intended for testing purposes and closed environments, code points in other ranges should not be assigned for testing.
            </t>

            <t>
              Specifications are required for the standards track range of point assignment.
              Specifications should exist for specification required ranges, but early assignment before a specification is available is considered to be permissible.
              Specifications are needed for the first-come, first-serve range if they are expected to be used outside of closed environments in an interoperable way.
              When specifications are not provided, the description provided needs to have sufficient information to identify what the point is being used for.
            </t>

            <t>
              Experts should take into account the expected usage of fields when approving point assignment.
              The fact that there is a range for standards track documents does not mean that a standards track document cannot have points assigned outside of that range.
              The length of the encoded value should be weighed against how many code points of that length are left, the size of device it will be used on, and the number of code points left that encode to that size.
            </t>

          </list>
        </t>
          
      </section>

    </section> <!-- ends from line 547-->

  </middle>

  <back>

    <references title="Normative References">

      &I-D.ietf-core-object-security;
      &I-D.ietf-ace-oauth-authz;
      &I-D.ietf-ace-oauth-params;
      &RFC8392;
      &RFC2119;
      &RFC7252;
      &RFC8152;

    </references>

    <references title='Informative References'>
      
      &I-D.gerdes-ace-dcaf-authorize;
      &I-D.selander-ace-cose-ecdhe;
      &RFC4949;
      &RFC6749;
      &RFC7049;
      &RFC7231;

    </references>

    <section title="Profile Requirements">

      <t>
        This section lists the specifications on this profile based on the requirements on the framework, as requested in Appendix C of <xref target="I-D.ietf-ace-oauth-authz"/>.
      </t>

      <t>
        <list style="symbols">
          <t>(Optional) discovery process of how the client finds the right AS for an RS it wants to send a request to: Not specified
          </t>
          <t>communication protocol the client and the RS must use: CoAP
          </t>
          <t>security protocol the client and RS must use: OSCORE
          </t>
          <t>how the client and the RS mutually authenticate: Implicitly by possession of a common OSCORE security context
          </t>
          <t>Content-format of the protocol messages: "application/cose+cbor"
          </t>
          <t>proof-of-possession protocol(s) and how to select one; which key types (e.g. symmetric/asymmetric) supported: OSCORE algorithms; pre-established symmetric keys
          </t>
          <t>profile identifier: coap_oscore
          </t>
          <t>(Optional) how the RS talks to the AS for introspection: HTTP/CoAP (+ TLS/DTLS/OSCORE)
          </t>
          <t>how the client talks to the AS for requesting a token: HTTP/CoAP (+ TLS/DTLS/OSCORE)
          </t>
          <t>how/if the authz-info endpoint is protected: Security protocol above
          </t>
          <t>(Optional)other methods of token transport than the authz-info endpoint: no
          </t>
        </list>
      </t>

    </section>

<!--
    <section anchor= "oscore-edhoc" title="Using the pop-key with EDHOC (EDHOC+OSCORE)" >

      <t>
        EDHOC specifies an authenticated Diffie-Hellman protocol that allows two parties to use CBOR <xref target="RFC7049"/> and COSE in order to establish a shared secret key with perfect forward secrecy.  The use of Ephemeral Diffie-Hellman Over COSE (EDHOC) <xref target="I-D.selander-ace-cose-ecdhe"/> in this profile in addition to OSCORE, provides perfect forward secrecy (PFS) and the initial proof-of-possession, which ties the proof-of-possession key to an OSCORE security context.
      </t>

      <t>
        If EDHOC is used together with OSCORE, and the pop-key (symmetric or asymmetric) is used to authenticate the messages in EDHOC, then the AS MUST provision the following data, in response to the access token request:
      <!- - Jim: Again the symmetric key is not a POP key. - ->
      </t>

      <t>
        <list style="symbols">
          <t>a symmetric or public key (associated to the RS)</t>
          <t>a key identifier;</t>
        </list>
      </t>

      <t>
        How these parameters are communicated depends on the type of key (asymmetric or symmetric).  Moreover, the AS MUST signal the use of OSCORE + EDHOC with the 'profile' parameter set to "coap_oscore_edhoc".
      </t>

      <t>
        Note that in the case described in this section, the 'expires_in' parameter, defined in Section 4.2.2. of <xref target="RFC6749"/> defines the lifetime in seconds of both the access token and the shared secret. After expiration, C MUST acquire a new access token from the AS, and run EDHOC again, as specified in this section
      </t>

      <section anchor="edhoc-asym" title="Using Asymmetric Keys">
        
        <t>
          In case of an asymmetric key, C MUST communicate its own asymmetric key to the AS in the 'req_cnf' parameter of the access token request, as specified in Section 3.1 of <xref target="I-D.ietf-ace-oauth-params"/>; the AS MUST communicate the RS's public key to C in the response, in the 'rs_cnf' parameter, as specified in Section 3.2 of <xref target="I-D.ietf-ace-oauth-params"/>. Note that the RS's public key MUST include a 'kid' parameter, and that the value of the 'kid' MUST be included in the access token, to let the RS know which of its public keys C used.  If the access token is a CWT <xref target="RFC8392"/>, the key identifier MUST be placed directly in the 'cnf' structure (if the key is only referenced).
        <!- - TODO: check that the rs_cnf is used correctly - ->
        </t>

        <t>
          Figure 3 shows an example of such a request in CBOR diagnostic notation without tag and value abbreviations.
        </t>

<figure><artwork><![CDATA[
Header: POST (Code=0.02)
Uri-Host: "server.example.com"
Uri-Path: "token"
Content-Type: "application/cose+cbor"
Payload:
{
 "grant_type" : "client_credentials",
 "req_cnf" : {
   "COSE_Key" : {
     "kid" : "client_key"
     "kty" : "EC",
     "crv" : "P-256",
     "x" : b64'usWxHK2PmfnHKwXPS54m0kTcGJ90UiglWiGahtagnv8',
     "y" : b64'IBOL+C3BttVivg+lSreASjpkttcsz+1rb7btKLv8EX4'
   }
 }
}

Figure 3: Example access token request (OSCORE+EDHOC, asymmetric).
]]></artwork></figure>

        <t>
          Figure 4 shows an example of a corresponding response in CBOR diagnostic notation without tag and value abbreviations.
        </t>

<figure><artwork><![CDATA[
  Header: Created (Code=2.01)
  Content-Type: "application/cose+cbor"
  Payload:
  {
    "access_token" : b64'SlAV32hkKG ...
     (contains "kid" : "client_key")',
    "profile" : "coap_oscore_edhoc",
    "expires_in" : "3600",
    "cnf" : {
      "COSE_Key" : {
        "kid" : "server_key"
        "kty" : "EC",
        "crv" : "P-256",
        "x" : b64'cGJ90UiglWiGahtagnv8usWxHK2PmfnHKwXPS54m0kT',
        "y" : b64'reASjpkttcsz+1rb7btKLv8EX4IBOL+C3BttVivg+lS'
     }
    }
  }

Figure 4: Example AS response (EDHOC+OSCORE, asymmetric).
]]></artwork></figure>

      </section> <!- - ends for line 299- ->

      <section anchor="edhoc-sym" title="Using Symmetric Keys">
        
        <t>
          In the case of a symmetric key, the AS MUST communicate the key to the client in the 'cnf' parameter of the access token response, as specified in Section 3.2. of <xref target="I-D.ietf-ace-oauth-params"/>.   The AS MUST also select a key identifier, that MUST be included as the 'kid' parameter of the COSE_key, as in figure 9 of <xref target="I-D.ietf-ace-oauth-authz"/>.
        </t>

        <t>
          Figure 5 shows an example of the necessary parameters in the AS response to the access token request when EDHOC is used.  The example uses CBOR  diagnostic notation without tag and value abbreviations.
        </t>

<figure><artwork><![CDATA[
  Header: Created (Code=2.01)
  Content-Type: "application/cose+cbor"
  Payload:
  {
    "access_token" : b64'SlAV32hkKG ...
     (remainder of access token omitted for brevity)',
    "profile" : "coap_oscore_edhoc",
    "expires_in" : "3600",
    "cnf" : {
      "COSE_Key" : {
        "kty" : "Symmetric",
        "kid" : b64'5tOS+h42dkw',
        "k" : b64'+a+Dg2jjU+eIiOFCa9lObw'
      }
    }
  }

Figure 5: Example AS response (EDHOC+OSCORE, symmetric).
]]></artwork></figure>

        <t>
          In both cases, the AS MUST also include the same key identifier as 'kid' parameter in the access token metadata. If the access token is a CWT <xref target="RFC8392"/>, the key identifier MUST be placed inside the 'cnf' claim as 'kid' parameter of the COSE_Key or directly in the 'cnf' structure (if the key is only referenced).
        </t>
        <t>
          Figure 6 shows an example CWT containing the necessary EDHOC+OSCORE parameters in the 'cnf' claim, in CBOR diagnostic notation without tag and value abbreviations.
        </t>

<figure><artwork><![CDATA[
{
  "aud" : "tempSensorInLivingRoom",
  "iat" : "1360189224",
  "exp" : "1360289224",
  "scope" :  "temperature_g firmware_p",
  "cnf" : {
    "COSE_Key" : {
      "kty" : "Symmetric",
      "kid" : b64'5tOS+h42dkw',
      "k" : b64'+a+Dg2jjU+eIiOFCa9lObw' 
  }
}

  Figure 6: Example CWT with EDHOC+OSCORE, symmetric case.
]]></artwork></figure>

        <t>
          All other parameters defining OSCORE security context are derived from EDHOC message exchange, including the master secret (see Appendix D.2 of <xref target="I-D.selander-ace-cose-ecdhe"/>).
        </t>

      </section> <!- - ends for line 361- ->

      <section anchor="edhoc-proc" title="Processing">
        
        <t>
          To provide forward secrecy and mutual authentication in the case of pre-shared keys, pre-established raw public keys or with X.509 certificates it is RECOMMENDED to use EDHOC <xref target="I-D.selander-ace-cose-ecdhe"/> to generate the keying material.  EDHOC MUST be used as defined in Appendix D of <xref target="I-D.selander-ace-cose-ecdhe"/>, with the following additions and modifications.
        </t>
        
        <t>
          The first EDHOC message is sent after the access token is posted to the authz-info endpoint of the RS as specified in Section 5.8.1 of <xref target="I-D.ietf-ace-oauth-authz"/>. Then the EDHOC message_1 is sent and the EDHOC protocol is initiated <xref target="I-D.selander-ace-cose-ecdhe"/>).
        </t>
        
        <t>
          Before the RS continues with the EDHOC protocol and responds to this token submission request, additional verifications on the access token are done: the RS SHALL process the access token according to <xref target="I-D.ietf-ace-oauth-authz"/>.  If the token is valid then the RS continues processing EDHOC following Appendix D of <xref target="I-D.selander-ace-cose-ecdhe"/>, otherwise it discontinues EDHOC and responds with the error code as specified in <xref target="I-D.ietf-ace-oauth-authz"/>.
        </t>

        <t>
          <list style="symbols">
            <t>In case the EDHOC verification fails, the RS MUST return an error response to the client with code 4.01 (Unauthorized).
            </t>
            <t>If RS has an access token for C but not for the resource that C has requested, RS MUST reject the request with a 4.03 (Forbidden).
            </t>
            <t>If RS has an access token for C but it does not cover the action C requested on the resource, RS MUST reject the request with a 4.05 (Method Not Allowed).
            </t>
            <t>If all verifications above succeeds, further communication between client and RS is protected with OSCORE, including the RS response to the OSCORE request.
            </t>
          </list>
        </t>

        <t>
          In the case of EDHOC being used with symmetric keys, the protocol in Section 5 of <xref target="I-D.selander-ace-cose-ecdhe"/> MUST be used.  If the key is asymmetric, the RS MUST also use an asymmetric key for authentication.  This key is known to the client through the access token response (see Section 5.6.2 of <xref target="I-D.ietf-ace-oauth-authz"/>).  In this case the protocol in Section 4 of <xref target="I-D.selander-ace-cose-ecdhe"/> MUST be used.
        </t>

        <t>
          Figure 7 illustrates the message exchanges for using OSCORE+EDHOC (step C in figure 1 of <xref target="I-D.ietf-ace-oauth-authz"/>).
        </t>

<figure><artwork><![CDATA[
                 Resource
        Client    Server
        |          |
        |          |
        +- - - - - - - - ->| Header: POST (Code=0.02)
        | POST     | Uri-Path:"authz-info"
        |          | Content-Type: application/cbor
        |          | Payload: access token
        |          |
        |          |
        +- - - - - - - - ->| Header: POST (Code=0.02)
        |   POST   | Uri-Path: "/.well-known/edhoc"
        |          | Content-Type: application/edhoc
        |          | Payload: EDHOC message_1
        |          |
        |<- - - - - - - - -+ Header: 2.04 Changed
        |   2.04   | Content-Type: application/edhoc
        |          | Payload: EDHOC message_2
        |          |
        +- - - - - - - - ->| Header: POST (Code=0.02)
        |   POST   | Uri-Path: "/.well-known/edhoc"
        |          | Content-Type: application/edhoc
        |          | Payload: EDHOC message_3
        |          |
        |<- - - - - - - - -+ Header: 2.04 Changed
        |   2.04   |
        |          |
 start of protected communication
        |          |
        +- - - - - - - - ->| CoAP request +
        |  OSCORE  | Object-Security option
        | request  | 
        |          |
        |<- - - - - - - - -+ CoAP response +
        |  OSCORE  | Object-Security option
        | response | 
        |          |  

Figure 7: Access token and key establishment with EDHOC
]]></artwork></figure>

<!- -
Jim: in the section above: Is there a reason for not supporting multiple edhoc negotiations w/ the same secret - it seemed to be an original mode that was supported.

where does it say that? - ->

      </section> <!- - ends for line 422- ->

    </section>
-->

    <section title="Acknowledgments" numbered='no'> 

      <t>
        The authors wish to thank Jim Schaad and Marco Tiloca for the input on this memo.
      </t>

    </section>

  </back>

</rfc>
